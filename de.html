<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>serde.de API documentation</title>
<meta name="description" content="Defines classes and functions for `deserialize` decorator â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>serde.de</code></h1>
</header>
<section id="section-intro">
<p>Defines classes and functions for <code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code> decorator.</p>
<p><code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code> is a decorator to make a <code>dataclasses.dataclass</code> class deserializable.
<code><a title="serde.de.is_deserializable" href="#serde.de.is_deserializable">is_deserializable()</a></code> is used to test a class is with <code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code>.
<code><a title="serde.de.Deserializer" href="#serde.de.Deserializer">Deserializer</a></code> is a deserializer base class used in <code>from_obj</code>,
<code><a title="serde.json.from_json" href="json.html#serde.json.from_json">from_json()</a></code>. You can subclass it to make your own deserializer.
<code>from_obj</code> deserializes from an object into an instance of the class with
<code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code>.</p>
<p><code>args_from_iter</code> and <code>args_from_dict</code> are private functions but they are the core
parts of pyserde.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines classes and functions for `deserialize` decorator.

`deserialize` is a decorator to make a `dataclasses.dataclass` class deserializable.
`is_deserializable` is used to test a class is with `deserialize`.
`Deserializer` is a deserializer base class used in `from_obj`,
`serde.json.from_json`. You can subclass it to make your own deserializer.
`from_obj` deserializes from an object into an instance of the class with
`deserialize`.

`args_from_iter` and `args_from_dict` are private functions but they are the core
parts of pyserde.
&#34;&#34;&#34;
import abc
import functools
import sys
from dataclasses import dataclass, is_dataclass
from datetime import date, datetime
from decimal import Decimal
from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
from pathlib import Path, PosixPath, PurePath, PurePosixPath, PureWindowsPath, WindowsPath
from typing import Any, Callable, Dict, List, Optional, Type
from uuid import UUID

import jinja2

from .compat import (
    T,
    has_default,
    has_default_factory,
    is_bare_dict,
    is_bare_list,
    is_bare_set,
    is_bare_tuple,
    is_dict,
    is_enum,
    is_list,
    is_none,
    is_opt,
    is_primitive,
    is_set,
    is_tuple,
    is_union,
    iter_types,
    iter_unions,
    type_args,
    typename,
)
from .core import (
    FROM_DICT,
    FROM_ITER,
    SERDE_SCOPE,
    UNION_DE_PREFIX,
    Field,
    SerdeError,
    SerdeScope,
    add_func,
    fields,
    logger,
    raise_unsupported_type,
    union_func_name,
)
from .py36_datetime_compat import py36_date_fromisoformat, py36_datetime_fromisoformat

__all__: List = [&#39;deserialize&#39;, &#39;is_deserializable&#39;, &#39;Deserializer&#39;, &#39;from_dict&#39;, &#39;from_tuple&#39;]

Custom = Optional[Callable[[&#39;DeField&#39;, Any], Any]]


def deserialize(
    _cls: Type[T] = None, rename_all: Optional[str] = None, reuse_instances_default: bool = True
) -&gt; Type[T]:
    &#34;&#34;&#34;
    `deserialize` decorator. A dataclass with this decorator can be deserialized
    into an object from various data format such as JSON and MsgPack.

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt; from serde.json import from_json
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Mark the class deserializable.
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     i: int
    ...     s: str
    ...     f: float
    ...     b: bool
    &gt;&gt;&gt; from_json(Foo, &#39;{&#34;i&#34;: 10, &#34;s&#34;: &#34;foo&#34;, &#34;f&#34;: 100.0, &#34;b&#34;: true}&#39;)
    Foo(i=10, s=&#39;foo&#39;, f=100.0, b=True)

    Additionally, `deserialize` supports case conversion. Pass case name in
    `deserialize` decorator as shown below.

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize(rename_all = &#39;camelcase&#39;)
    ... @dataclass
    ... class RenameAll:
    ...     int_field: int
    ...     str_field: str
    &gt;&gt;&gt; from_json(RenameAll, &#39;{&#34;intField&#34;: 10, &#34;strField&#34;: &#34;foo&#34;}&#39;)
    RenameAll(int_field=10, str_field=&#39;foo&#39;)
    &#34;&#34;&#34;

    def wrap(cls: Type):
        g: Dict[str, Any] = {}

        # Create a scope storage used by serde.
        # Each class should get own scope. Child classes can not share scope with parent class.
        # That&#39;s why we need the &#34;scope.cls is not cls&#34; check.
        scope: SerdeScope = getattr(cls, SERDE_SCOPE, None)
        if scope is None or scope.cls is not cls:
            scope = SerdeScope(cls, reuse_instances_default=reuse_instances_default)
            setattr(cls, SERDE_SCOPE, scope)

        # Set some globals for all generated functions
        g[&#39;cls&#39;] = cls
        g[&#39;serde_scope&#39;] = scope
        g[&#39;SerdeError&#39;] = SerdeError
        g[&#39;raise_unsupported_type&#39;] = raise_unsupported_type
        g[&#39;typename&#39;] = typename  # used in union functions

        # Collect types used in the generated code.
        for typ in iter_types(cls):
            if typ is cls:
                continue

            if typ is Any:
                continue

            if is_dataclass(typ) or is_enum(typ) or not is_primitive(typ):
                scope.types[typ.__name__] = typ

            # python 3.6 has no fromisoformat functions for date &amp; datetime, so we have to add our own.
            # See Renderer.render for usage
            if sys.version_info[:2] == (3, 6):
                if typ is date:
                    g[&#39;__py36_date_fromisoformat__&#39;] = py36_date_fromisoformat
                elif typ is datetime:
                    g[&#39;__py36_datetime_fromisoformat__&#39;] = py36_datetime_fromisoformat

        # render all union functions
        for union in iter_unions(cls):
            union_args = type_args(union)
            add_func(scope, union_func_name(UNION_DE_PREFIX, union_args), render_union_func(cls, union_args), g)

        # Collect default values and default factories used in the generated code.
        for f in defields(cls):
            assert f.name
            if has_default(f):
                scope.defaults[f.name] = f.default
            elif has_default_factory(f):
                scope.defaults[f.name] = f.default_factory
            if f.deserialize:
                g[f.deserialize.name] = f.deserialize

        add_func(scope, FROM_ITER, render_from_iter(cls), g)
        add_func(scope, FROM_DICT, render_from_dict(cls, rename_all), g)

        logger.debug(f&#39;{cls.__name__}: {SERDE_SCOPE} {scope}&#39;)

        return cls

    if _cls is None:
        return wrap  # type: ignore

    return wrap(_cls)


def is_deserializable(instance_or_class: Any) -&gt; bool:
    &#34;&#34;&#34;
    Test if arg can `deserialize`. Arg must be also an instance of class.

    &gt;&gt;&gt; from serde import deserialize, is_deserializable
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     pass
    &gt;&gt;&gt;
    &gt;&gt;&gt; is_deserializable(Foo)
    True
    &#34;&#34;&#34;
    return hasattr(instance_or_class, SERDE_SCOPE)


class Deserializer(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    `Deserializer` base class. Subclass this to customize deserialize behaviour.

    See `serde.json.JsonDeserializer` and `serde.msgpack.MsgPackDeserializer` for example usage.
    &#34;&#34;&#34;

    @abc.abstractclassmethod
    def deserialize(cls, data, **opts):
        &#34;&#34;&#34;
        deserialize `data` into an object typically `dict`, `list` or `tuple`.

        For example, `serde.json.JsonDeserializer` takes json string and deserialize
        into an object. `serde.msgpack.MsgPackDeserializer` takes msgpack bytes and
        deserialize into an object.
        &#34;&#34;&#34;


def from_obj(c: Type, o: Any, named: bool, reuse_instances: bool):
    &#34;&#34;&#34;
    Deserialize from an object into an instance of the type specified as arg `c`.
    `c` can be either primitive type, `List`, `Tuple`, `Dict` or `deserialize` class.
    &#34;&#34;&#34;
    thisfunc = functools.partial(from_obj, named=named, reuse_instances=reuse_instances)
    if o is None:
        return None
    if is_deserializable(c):
        serde_scope: SerdeScope = getattr(c, SERDE_SCOPE)
        if named:
            return serde_scope.funcs[FROM_DICT](o, reuse_instances=reuse_instances)
        else:
            return serde_scope.funcs[FROM_ITER](o, reuse_instances=reuse_instances)
    elif is_opt(c):
        if o is None:
            return None
        else:
            return thisfunc(type_args(c)[0], o)
    elif is_union(c):
        v = None
        for typ in type_args(c):
            try:
                v = thisfunc(typ, o)
                break
            except (SerdeError, ValueError):
                pass
        return v
    elif is_list(c) or is_set(c):
        return [thisfunc(type_args(c)[0], e) for e in o]
    elif is_tuple(c):
        return tuple(thisfunc(type_args(c)[i], e) for i, e in enumerate(o))
    elif is_dict(c):
        return {thisfunc(type_args(c)[0], k): thisfunc(type_args(c)[1], v) for k, v in o.items()}

    return o


def from_dict(cls, o, reuse_instances: bool = ...):
    &#34;&#34;&#34;
    Deserialize from dictionary.

    ### Dataclass

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     i: int
    ...     f: float
    ...     s: str
    ...     b: bool
    &gt;&gt;&gt;
    &gt;&gt;&gt; obj = {&#39;i&#39;: 10, &#39;f&#39;: 0.1, &#39;s&#39;: &#39;foo&#39;, &#39;b&#39;: False}
    &gt;&gt;&gt; from_dict(Foo, obj)
    Foo(i=10, f=0.1, s=&#39;foo&#39;, b=False)

    ### Containers

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt; from typing import List
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     i: int
    &gt;&gt;&gt;
    &gt;&gt;&gt; from_dict(List[Foo], [{&#39;i&#39;: 10}, {&#39;i&#39;: 20}])
    [Foo(i=10), Foo(i=20)]
    &gt;&gt;&gt;
    &gt;&gt;&gt; from_dict(Dict[str, Foo], {&#39;foo1&#39;: {&#39;i&#39;: 10}, &#39;foo2&#39;: {&#39;i&#39;: 20}})
    {&#39;foo1&#39;: Foo(i=10), &#39;foo2&#39;: Foo(i=20)}
    &#34;&#34;&#34;
    return from_obj(cls, o, named=True, reuse_instances=reuse_instances)


def from_tuple(cls, o, reuse_instances: bool = ...):
    &#34;&#34;&#34;
    Deserialize from tuple.
    &#34;&#34;&#34;
    return from_obj(cls, o, named=False, reuse_instances=reuse_instances)


@dataclass
class DeField(Field):
    &#34;&#34;&#34;
    Field class for deserialization.
    &#34;&#34;&#34;

    datavar: Optional[str] = None  # name of variable to deserialize from.
    index: int = 0  # Field index.
    iterbased: bool = False  # Iterater based deserializer or not.

    def __getitem__(self, n) -&gt; &#39;DeField&#39;:
        &#34;&#34;&#34;
        Access inner `Field` e.g. T of List[T].
        &#34;&#34;&#34;
        typ = type_args(self.type)[n]
        opts = {
            &#39;case&#39;: self.case,
            &#39;rename&#39;: self.rename,
            &#39;skip&#39;: self.skip,
            &#39;skip_if&#39;: self.skip_if,
            &#39;skip_if_false&#39;: self.skip_if_false,
        }
        if is_list(self.type) or is_dict(self.type) or is_set(self.type):
            return InnerField(typ, &#39;v&#39;, datavar=&#39;v&#39;, **opts)
        elif is_tuple(self.type):
            return InnerField(typ, f&#39;{self.data}[{n}]&#39;, datavar=f&#39;{self.data}[{n}]&#39;, **opts)
        else:
            return DeField(typ, self.name, datavar=self.datavar, index=self.index, iterbased=self.iterbased, **opts)

    def key_field(self) -&gt; &#39;DeField&#39;:
        &#34;&#34;&#34;
        Get inner key field for Dict like class.
        &#34;&#34;&#34;
        k = self[0]
        k.name = &#39;k&#39;
        k.datavar = &#39;k&#39;
        return k

    def value_field(self) -&gt; &#39;DeField&#39;:
        &#34;&#34;&#34;
        Get inner value field for Dict like class.
        &#34;&#34;&#34;
        return self[1]

    @property
    def data(self) -&gt; str:
        if self.iterbased:
            return f&#39;{self.datavar}[{self.index}]&#39;
        else:
            return f&#39;{self.datavar}[&#34;{self.conv_name()}&#34;]&#39;

    @data.setter
    def data(self, d):
        self.datavar = d


@dataclass
class InnerField(DeField):
    &#34;&#34;&#34;
    Field for inner type e.g. T of List[T].
    &#34;&#34;&#34;

    @property
    def data(self) -&gt; str:
        return self.datavar or &#39;&#39;

    @data.setter
    def data(self, d):
        self.datavar = d


defields = functools.partial(fields, DeField)


@dataclass
class Renderer:
    &#34;&#34;&#34;
    Render rvalue for code generation.
    &#34;&#34;&#34;

    func: str

    def render(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue
        &#34;&#34;&#34;
        if arg.serialize:
            res = self.custom_field_deserializer(arg)
        elif is_dataclass(arg.type):
            res = self.dataclass(arg)
        elif is_opt(arg.type):
            res = self.opt(arg)
        elif is_list(arg.type):
            res = self.list(arg)
        elif is_set(arg.type):
            res = self.set(arg)
        elif is_dict(arg.type):
            res = self.dict(arg)
        elif is_tuple(arg.type):
            res = self.tuple(arg)
        elif is_enum(arg.type):
            res = self.enum(arg)
        elif is_primitive(arg.type):
            res = self.primitive(arg)
        elif is_union(arg.type):
            res = self.union_func(arg)
        elif arg.type in [
            Decimal,
            Path,
            PosixPath,
            WindowsPath,
            PurePath,
            PurePosixPath,
            PureWindowsPath,
            UUID,
            IPv4Address,
            IPv6Address,
            IPv4Network,
            IPv6Network,
            IPv4Interface,
            IPv6Interface,
        ]:
            res = f&#34;({self.c_tor_with_check(arg)}) if reuse_instances else {self.c_tor(arg)}&#34;
        elif arg.type in [date, datetime]:
            from_iso = f&#34;{arg.type.__name__}.fromisoformat({arg.data})&#34;

            if sys.version_info[:2] == (3, 6):  # python 3.6 has no fromisoformat functions
                if arg.type is date:
                    from_iso = f&#34;__py36_date_fromisoformat__({arg.data})&#34;
                elif arg.type is datetime:
                    from_iso = f&#34;__py36_datetime_fromisoformat__({arg.data})&#34;

            res = f&#34;({arg.data} if isinstance({arg.data}, {arg.type.__name__}) else {from_iso}) \
                    if reuse_instances else {from_iso}&#34;
        elif is_none(arg.type):
            res = &#34;None&#34;
        elif arg.type is Any:
            res = arg.data
        else:
            return f&#34;raise_unsupported_type({arg.data})&#34;

        if has_default(arg) or has_default_factory(arg):
            if arg.iterbased:
                exists = f&#39;{arg.data} is not None&#39;
            else:
                exists = f&#39;{arg.datavar}.get(&#34;{arg.conv_name()}&#34;) is not None&#39;
            if has_default(arg):
                res = f&#39;({res}) if {exists} else serde_scope.defaults[&#34;{arg.name}&#34;]&#39;
            elif has_default_factory(arg):
                res = f&#39;({res}) if {exists} else serde_scope.defaults[&#34;{arg.name}&#34;]()&#39;

        return res

    def custom_field_deserializer(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue for the field with custom deserializer.
        &#34;&#34;&#34;
        assert arg.deserialize
        return f&#34;{arg.deserialize.name}({arg.data})&#34;

    def dataclass(self, arg: DeField) -&gt; str:
        return f&#34;{arg.type.__name__}.{SERDE_SCOPE}.funcs[&#39;{self.func}&#39;]({arg.data}, reuse_instances=reuse_instances)&#34;

    def opt(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue for Optional.

        &gt;&gt;&gt; from typing import List
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Optional[int], &#39;o&#39;, datavar=&#39;data&#39;))
        &#39;(data[&#34;o&#34;]) if data.get(&#34;o&#34;) is not None else None&#39;

        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Optional[List[int]], &#39;o&#39;, datavar=&#39;data&#39;))
        &#39;([v for v in data[&#34;o&#34;]]) if data.get(&#34;o&#34;) is not None else None&#39;

        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Optional[List[int]], &#39;o&#39;, datavar=&#39;data&#39;))
        &#39;([v for v in data[&#34;o&#34;]]) if data.get(&#34;o&#34;) is not None else None&#39;

        &gt;&gt;&gt; @deserialize
        ... @dataclass
        ... class Foo:
        ...     o: Optional[List[int]]
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Optional[Foo], &#39;f&#39;, datavar=&#39;data&#39;))
        &#39;(Foo.__serde__.funcs[\\&#39;foo\\&#39;](data[&#34;f&#34;], reuse_instances=reuse_instances)) \
if data.get(&#34;f&#34;) is not None else None&#39;
        &#34;&#34;&#34;
        value = arg[0]
        if has_default(arg):
            return self.render(value)
        else:
            if arg.iterbased:
                exists = f&#39;{arg.data} is not None&#39;
            else:
                exists = f&#39;{arg.datavar}.get(&#34;{arg.conv_name()}&#34;) is not None&#39;
            return f&#39;({self.render(value)}) if {exists} else None&#39;

    def list(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue for list.

        &gt;&gt;&gt; from typing import List
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(List[int], &#39;l&#39;, datavar=&#39;data&#39;))
        &#39;[v for v in data[&#34;l&#34;]]&#39;

        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(List[List[int]], &#39;l&#39;, datavar=&#39;data&#39;))
        &#39;[[v for v in v] for v in data[&#34;l&#34;]]&#39;
        &#34;&#34;&#34;
        if is_bare_list(arg.type):
            return f&#39;list({arg.data})&#39;
        else:
            return f&#39;[{self.render(arg[0])} for v in {arg.data}]&#39;

    def set(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue for set.

        &gt;&gt;&gt; from typing import Set
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Set[int], &#39;l&#39;, datavar=&#39;data&#39;))
        &#39;set(v for v in data[&#34;l&#34;])&#39;

        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Set[Set[int]], &#39;l&#39;, datavar=&#39;data&#39;))
        &#39;set(set(v for v in v) for v in data[&#34;l&#34;])&#39;
        &#34;&#34;&#34;
        if is_bare_set(arg.type):
            return f&#39;set({arg.data})&#39;
        else:
            return f&#39;set({self.render(arg[0])} for v in {arg.data})&#39;

    def tuple(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue for tuple.

        &gt;&gt;&gt; from typing import List, Tuple
        &gt;&gt;&gt; @deserialize
        ... @dataclass
        ... class Foo: pass
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Tuple[str, int, List[int], Foo], &#39;d&#39;, datavar=&#39;data&#39;))
        &#39;(data[&#34;d&#34;][0], data[&#34;d&#34;][1], [v for v in data[&#34;d&#34;][2]], \
Foo.__serde__.funcs[\\&#39;foo\\&#39;](data[&#34;d&#34;][3], reuse_instances=reuse_instances),)&#39;

        &gt;&gt;&gt; field = DeField(Tuple[str, int, List[int], Foo], &#39;d&#39;, datavar=&#39;data&#39;, index=0, iterbased=True)
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(field)
        &#34;(data[0][0], data[0][1], [v for v in data[0][2]], \
Foo.__serde__.funcs[&#39;foo&#39;](data[0][3], reuse_instances=reuse_instances),)&#34;
        &#34;&#34;&#34;
        if is_bare_tuple(arg.type):
            return f&#39;tuple({arg.data})&#39;
        else:
            values = []
            for i, typ in enumerate(type_args(arg.type)):
                inner = arg[i]
                values.append(self.render(inner))
            return f&#39;({&#34;, &#34;.join(values)},)&#39;  # trailing , is required for single element tuples

    def dict(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue for dict.

        &gt;&gt;&gt; from typing import List
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Dict[str, int], &#39;d&#39;, datavar=&#39;data&#39;))
        &#39;{k: v for k, v in data[&#34;d&#34;].items()}&#39;

        &gt;&gt;&gt; @deserialize
        ... @dataclass
        ... class Foo: pass
        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(Dict[Foo, List[Foo]], &#39;f&#39;, datavar=&#39;data&#39;))
        &#39;{Foo.__serde__.funcs[\\&#39;foo\\&#39;](k, reuse_instances=reuse_instances): \
[Foo.__serde__.funcs[\\&#39;foo\\&#39;](v, reuse_instances=reuse_instances) for v in v] for k, v in data[&#34;f&#34;].items()}&#39;
        &#34;&#34;&#34;
        if is_bare_dict(arg.type):
            return arg.data
        else:
            k = arg.key_field()
            v = arg.value_field()
            return f&#39;{{{self.render(k)}: {self.render(v)} for k, v in {arg.data}.items()}}&#39;

    def enum(self, arg: DeField) -&gt; str:
        return f&#39;{arg.type.__name__}({self.primitive(arg)})&#39;

    def primitive(self, arg: DeField) -&gt; str:
        &#34;&#34;&#34;
        Render rvalue for primitives.

        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(int, &#39;i&#39;, datavar=&#39;data&#39;))
        &#39;data[&#34;i&#34;]&#39;

        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(int, &#39;int_field&#39;, datavar=&#39;data&#39;, case=&#39;camelcase&#39;))
        &#39;data[&#34;intField&#34;]&#39;

        &gt;&gt;&gt; Renderer(&#39;foo&#39;).render(DeField(int, &#39;i&#39;, datavar=&#39;data&#39;, index=1, iterbased=True))
        &#39;data[1]&#39;
        &#34;&#34;&#34;
        return arg.data

    def c_tor(self, arg: DeField) -&gt; str:
        return f&#34;{arg.type.__name__}({arg.data})&#34;

    def c_tor_with_check(self, arg: DeField, ctor: Optional[str] = None) -&gt; str:
        if ctor is None:
            ctor = self.c_tor(arg)
        return f&#34;{arg.data} if isinstance({arg.data}, {arg.type.__name__}) else {ctor}&#34;

    def union_func(self, arg: DeField) -&gt; str:
        func_name = union_func_name(UNION_DE_PREFIX, type_args(arg.type))
        return f&#34;serde_scope.funcs[&#39;{func_name}&#39;]({arg.data}, reuse_instances)&#34;


def to_arg(f: DeField, index, rename_all: Optional[str] = None) -&gt; DeField:
    f.index = index
    f.data = &#39;data&#39;
    f.case = f.case or rename_all
    return f


def to_iter_arg(f: DeField, *args, **kwargs) -&gt; DeField:
    f = to_arg(f, *args, **kwargs)
    f.iterbased = True
    return f


def render_from_iter(cls: Type) -&gt; str:
    template = &#34;&#34;&#34;
def {{func}}(data, reuse_instances = {{serde_scope.reuse_instances_default}}):
  if reuse_instances is Ellipsis:
    reuse_instances = {{serde_scope.reuse_instances_default}}

  {# List up all classes used by this class. -#}
  {% for name in serde_scope.types.keys() -%}
  {{name}} = serde_scope.types[&#39;{{name}}&#39;]
  {% endfor -%}

  if data is None:
    return None

  return cls(
  {% for f in fields %}
  {{f|arg(loop.index-1)|rvalue}},
  {% endfor %}
  )
    &#34;&#34;&#34;

    renderer = Renderer(FROM_ITER)
    env = jinja2.Environment(loader=jinja2.DictLoader({&#39;iter&#39;: template}))
    env.filters.update({&#39;rvalue&#39;: renderer.render})
    env.filters.update({&#39;arg&#39;: to_iter_arg})
    return env.get_template(&#39;iter&#39;).render(func=FROM_ITER, serde_scope=getattr(cls, SERDE_SCOPE), fields=defields(cls))


def render_from_dict(cls: Type, rename_all: Optional[str] = None) -&gt; str:
    template = &#34;&#34;&#34;
def {{func}}(data, reuse_instances = {{serde_scope.reuse_instances_default}}):
  if reuse_instances is Ellipsis:
    reuse_instances = {{serde_scope.reuse_instances_default}}

  {# List up all classes used by this class. #}
  {% for name in serde_scope.types.keys() %}
  {{name}} = serde_scope.types[&#39;{{name}}&#39;]
  {% endfor %}

  if data is None:
    return None

  return cls(
  {% for f in fields %}
  {{f|arg(loop.index-1)|rvalue}},
  {% endfor %}
  )
    &#34;&#34;&#34;

    renderer = Renderer(FROM_DICT)
    env = jinja2.Environment(loader=jinja2.DictLoader({&#39;dict&#39;: template}))
    env.filters.update({&#39;rvalue&#39;: renderer.render})
    env.filters.update({&#39;arg&#39;: functools.partial(to_arg, rename_all=rename_all)})
    return env.get_template(&#39;dict&#39;).render(func=FROM_DICT, serde_scope=getattr(cls, SERDE_SCOPE), fields=defields(cls))


def render_union_func(cls: Type, union_args: List[Type]) -&gt; str:
    template = &#34;&#34;&#34;
def {{func}}(data, reuse_instances):
  {% for name in serde_scope.types.keys() %}
  {{name}} = serde_scope.types[&#39;{{name}}&#39;]
  {% endfor %}

  # create fake dict so we can reuse the normal render function
  fake_dict = {&#34;fake_key&#34;:data}

  errors = []
  {% for t in union_args %}
  {% if t | is_primitive or t | is_none %}
  if isinstance(data, {{t.__name__}}):
    return {{t|arg|rvalue}}
  else:
    errors.append(&#34;input is not of type {{t.__name__}}&#34;)
  {% else %}
  try:
    return {{t|arg|rvalue}}
  except Exception as e:
    errors.append(f&#39; Failed to deserialize into {{t.__name__}}: {e}&#39;)
  {% endif %}
  {% endfor %}
  raise SerdeError(&#34;Can not deserialize &#34; + repr(data) + &#34; of type &#34; + \
          typename(type(data)) + &#34; into {{union_name}}.\\nReasons:\\n&#34; + &#34;\\n&#34;.join(errors))
    &#34;&#34;&#34;
    union_name = f&#34;Union[{&#39;, &#39;.join([typename(a) for a in union_args])}]&#34;

    renderer = Renderer(FROM_DICT)
    env = jinja2.Environment(loader=jinja2.DictLoader({&#39;dict&#39;: template}))
    env.filters.update(
        {&#39;arg&#39;: lambda x: DeField(x, datavar=&#34;fake_dict&#34;, name=&#34;fake_key&#34;)}
    )  # use custom to_arg for fake field
    env.filters.update({&#39;rvalue&#39;: renderer.render})
    env.filters.update({&#39;is_primitive&#39;: is_primitive})
    env.filters.update({&#39;is_none&#39;: is_none})
    return env.get_template(&#39;dict&#39;).render(
        func=union_func_name(UNION_DE_PREFIX, union_args),
        serde_scope=getattr(cls, SERDE_SCOPE),
        union_args=union_args,
        union_name=union_name,
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="serde.de.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>rename_all:Â Union[str,Â NoneType]Â =Â None, reuse_instances_default:Â boolÂ =Â True) â€‘>Â Type[~T]</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code> decorator. A dataclass with this decorator can be deserialized
into an object from various data format such as JSON and MsgPack.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from serde import deserialize
&gt;&gt;&gt; from serde.json import from_json
&gt;&gt;&gt;
&gt;&gt;&gt; # Mark the class deserializable.
&gt;&gt;&gt; @deserialize
... @dataclass
... class Foo:
...     i: int
...     s: str
...     f: float
...     b: bool
&gt;&gt;&gt; from_json(Foo, '{&quot;i&quot;: 10, &quot;s&quot;: &quot;foo&quot;, &quot;f&quot;: 100.0, &quot;b&quot;: true}')
Foo(i=10, s='foo', f=100.0, b=True)
</code></pre>
<p>Additionally, <code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code> supports case conversion. Pass case name in
<code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code> decorator as shown below.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from serde import deserialize
&gt;&gt;&gt;
&gt;&gt;&gt; @deserialize(rename_all = 'camelcase')
... @dataclass
... class RenameAll:
...     int_field: int
...     str_field: str
&gt;&gt;&gt; from_json(RenameAll, '{&quot;intField&quot;: 10, &quot;strField&quot;: &quot;foo&quot;}')
RenameAll(int_field=10, str_field='foo')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deserialize(
    _cls: Type[T] = None, rename_all: Optional[str] = None, reuse_instances_default: bool = True
) -&gt; Type[T]:
    &#34;&#34;&#34;
    `deserialize` decorator. A dataclass with this decorator can be deserialized
    into an object from various data format such as JSON and MsgPack.

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt; from serde.json import from_json
    &gt;&gt;&gt;
    &gt;&gt;&gt; # Mark the class deserializable.
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     i: int
    ...     s: str
    ...     f: float
    ...     b: bool
    &gt;&gt;&gt; from_json(Foo, &#39;{&#34;i&#34;: 10, &#34;s&#34;: &#34;foo&#34;, &#34;f&#34;: 100.0, &#34;b&#34;: true}&#39;)
    Foo(i=10, s=&#39;foo&#39;, f=100.0, b=True)

    Additionally, `deserialize` supports case conversion. Pass case name in
    `deserialize` decorator as shown below.

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize(rename_all = &#39;camelcase&#39;)
    ... @dataclass
    ... class RenameAll:
    ...     int_field: int
    ...     str_field: str
    &gt;&gt;&gt; from_json(RenameAll, &#39;{&#34;intField&#34;: 10, &#34;strField&#34;: &#34;foo&#34;}&#39;)
    RenameAll(int_field=10, str_field=&#39;foo&#39;)
    &#34;&#34;&#34;

    def wrap(cls: Type):
        g: Dict[str, Any] = {}

        # Create a scope storage used by serde.
        # Each class should get own scope. Child classes can not share scope with parent class.
        # That&#39;s why we need the &#34;scope.cls is not cls&#34; check.
        scope: SerdeScope = getattr(cls, SERDE_SCOPE, None)
        if scope is None or scope.cls is not cls:
            scope = SerdeScope(cls, reuse_instances_default=reuse_instances_default)
            setattr(cls, SERDE_SCOPE, scope)

        # Set some globals for all generated functions
        g[&#39;cls&#39;] = cls
        g[&#39;serde_scope&#39;] = scope
        g[&#39;SerdeError&#39;] = SerdeError
        g[&#39;raise_unsupported_type&#39;] = raise_unsupported_type
        g[&#39;typename&#39;] = typename  # used in union functions

        # Collect types used in the generated code.
        for typ in iter_types(cls):
            if typ is cls:
                continue

            if typ is Any:
                continue

            if is_dataclass(typ) or is_enum(typ) or not is_primitive(typ):
                scope.types[typ.__name__] = typ

            # python 3.6 has no fromisoformat functions for date &amp; datetime, so we have to add our own.
            # See Renderer.render for usage
            if sys.version_info[:2] == (3, 6):
                if typ is date:
                    g[&#39;__py36_date_fromisoformat__&#39;] = py36_date_fromisoformat
                elif typ is datetime:
                    g[&#39;__py36_datetime_fromisoformat__&#39;] = py36_datetime_fromisoformat

        # render all union functions
        for union in iter_unions(cls):
            union_args = type_args(union)
            add_func(scope, union_func_name(UNION_DE_PREFIX, union_args), render_union_func(cls, union_args), g)

        # Collect default values and default factories used in the generated code.
        for f in defields(cls):
            assert f.name
            if has_default(f):
                scope.defaults[f.name] = f.default
            elif has_default_factory(f):
                scope.defaults[f.name] = f.default_factory
            if f.deserialize:
                g[f.deserialize.name] = f.deserialize

        add_func(scope, FROM_ITER, render_from_iter(cls), g)
        add_func(scope, FROM_DICT, render_from_dict(cls, rename_all), g)

        logger.debug(f&#39;{cls.__name__}: {SERDE_SCOPE} {scope}&#39;)

        return cls

    if _cls is None:
        return wrap  # type: ignore

    return wrap(_cls)</code></pre>
</details>
</dd>
<dt id="serde.de.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>cls, o, reuse_instances:Â boolÂ =Â Ellipsis)</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize from dictionary.</p>
<h3 id="dataclass">Dataclass</h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; from serde import deserialize
&gt;&gt;&gt;
&gt;&gt;&gt; @deserialize
... @dataclass
... class Foo:
...     i: int
...     f: float
...     s: str
...     b: bool
&gt;&gt;&gt;
&gt;&gt;&gt; obj = {'i': 10, 'f': 0.1, 's': 'foo', 'b': False}
&gt;&gt;&gt; from_dict(Foo, obj)
Foo(i=10, f=0.1, s='foo', b=False)
</code></pre>
<h3 id="containers">Containers</h3>
<pre><code class="language-python-repl">&gt;&gt;&gt; from serde import deserialize
&gt;&gt;&gt; from typing import List
&gt;&gt;&gt;
&gt;&gt;&gt; @deserialize
... @dataclass
... class Foo:
...     i: int
&gt;&gt;&gt;
&gt;&gt;&gt; from_dict(List[Foo], [{'i': 10}, {'i': 20}])
[Foo(i=10), Foo(i=20)]
&gt;&gt;&gt;
&gt;&gt;&gt; from_dict(Dict[str, Foo], {'foo1': {'i': 10}, 'foo2': {'i': 20}})
{'foo1': Foo(i=10), 'foo2': Foo(i=20)}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_dict(cls, o, reuse_instances: bool = ...):
    &#34;&#34;&#34;
    Deserialize from dictionary.

    ### Dataclass

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     i: int
    ...     f: float
    ...     s: str
    ...     b: bool
    &gt;&gt;&gt;
    &gt;&gt;&gt; obj = {&#39;i&#39;: 10, &#39;f&#39;: 0.1, &#39;s&#39;: &#39;foo&#39;, &#39;b&#39;: False}
    &gt;&gt;&gt; from_dict(Foo, obj)
    Foo(i=10, f=0.1, s=&#39;foo&#39;, b=False)

    ### Containers

    &gt;&gt;&gt; from serde import deserialize
    &gt;&gt;&gt; from typing import List
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     i: int
    &gt;&gt;&gt;
    &gt;&gt;&gt; from_dict(List[Foo], [{&#39;i&#39;: 10}, {&#39;i&#39;: 20}])
    [Foo(i=10), Foo(i=20)]
    &gt;&gt;&gt;
    &gt;&gt;&gt; from_dict(Dict[str, Foo], {&#39;foo1&#39;: {&#39;i&#39;: 10}, &#39;foo2&#39;: {&#39;i&#39;: 20}})
    {&#39;foo1&#39;: Foo(i=10), &#39;foo2&#39;: Foo(i=20)}
    &#34;&#34;&#34;
    return from_obj(cls, o, named=True, reuse_instances=reuse_instances)</code></pre>
</details>
</dd>
<dt id="serde.de.from_tuple"><code class="name flex">
<span>def <span class="ident">from_tuple</span></span>(<span>cls, o, reuse_instances:Â boolÂ =Â Ellipsis)</span>
</code></dt>
<dd>
<div class="desc"><p>Deserialize from tuple.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_tuple(cls, o, reuse_instances: bool = ...):
    &#34;&#34;&#34;
    Deserialize from tuple.
    &#34;&#34;&#34;
    return from_obj(cls, o, named=False, reuse_instances=reuse_instances)</code></pre>
</details>
</dd>
<dt id="serde.de.is_deserializable"><code class="name flex">
<span>def <span class="ident">is_deserializable</span></span>(<span>instance_or_class:Â Any) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>Test if arg can <code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize()</a></code>. Arg must be also an instance of class.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from serde import deserialize, is_deserializable
&gt;&gt;&gt;
&gt;&gt;&gt; @deserialize
... @dataclass
... class Foo:
...     pass
&gt;&gt;&gt;
&gt;&gt;&gt; is_deserializable(Foo)
True
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_deserializable(instance_or_class: Any) -&gt; bool:
    &#34;&#34;&#34;
    Test if arg can `deserialize`. Arg must be also an instance of class.

    &gt;&gt;&gt; from serde import deserialize, is_deserializable
    &gt;&gt;&gt;
    &gt;&gt;&gt; @deserialize
    ... @dataclass
    ... class Foo:
    ...     pass
    &gt;&gt;&gt;
    &gt;&gt;&gt; is_deserializable(Foo)
    True
    &#34;&#34;&#34;
    return hasattr(instance_or_class, SERDE_SCOPE)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="serde.de.Deserializer"><code class="flex name class">
<span>class <span class="ident">Deserializer</span></span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="serde.de.Deserializer" href="#serde.de.Deserializer">Deserializer</a></code> base class. Subclass this to customize deserialize behaviour.</p>
<p>See <code><a title="serde.json.JsonDeserializer" href="json.html#serde.json.JsonDeserializer">JsonDeserializer</a></code> and <code><a title="serde.msgpack.MsgPackDeserializer" href="msgpack.html#serde.msgpack.MsgPackDeserializer">MsgPackDeserializer</a></code> for example usage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Deserializer(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;
    `Deserializer` base class. Subclass this to customize deserialize behaviour.

    See `serde.json.JsonDeserializer` and `serde.msgpack.MsgPackDeserializer` for example usage.
    &#34;&#34;&#34;

    @abc.abstractclassmethod
    def deserialize(cls, data, **opts):
        &#34;&#34;&#34;
        deserialize `data` into an object typically `dict`, `list` or `tuple`.

        For example, `serde.json.JsonDeserializer` takes json string and deserialize
        into an object. `serde.msgpack.MsgPackDeserializer` takes msgpack bytes and
        deserialize into an object.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="serde.json.JsonDeserializer" href="json.html#serde.json.JsonDeserializer">JsonDeserializer</a></li>
<li><a title="serde.msgpack.MsgPackDeserializer" href="msgpack.html#serde.msgpack.MsgPackDeserializer">MsgPackDeserializer</a></li>
<li><a title="serde.toml.TomlDeserializer" href="toml.html#serde.toml.TomlDeserializer">TomlDeserializer</a></li>
<li><a title="serde.yaml.YamlDeserializer" href="yaml.html#serde.yaml.YamlDeserializer">YamlDeserializer</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="serde.de.Deserializer.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>data, **opts)</span>
</code></dt>
<dd>
<div class="desc"><p>deserialize <code>data</code> into an object typically <code>dict</code>, <code>list</code> or <code>tuple</code>.</p>
<p>For example, <code><a title="serde.json.JsonDeserializer" href="json.html#serde.json.JsonDeserializer">JsonDeserializer</a></code> takes json string and deserialize
into an object. <code><a title="serde.msgpack.MsgPackDeserializer" href="msgpack.html#serde.msgpack.MsgPackDeserializer">MsgPackDeserializer</a></code> takes msgpack bytes and
deserialize into an object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abc.abstractclassmethod
def deserialize(cls, data, **opts):
    &#34;&#34;&#34;
    deserialize `data` into an object typically `dict`, `list` or `tuple`.

    For example, `serde.json.JsonDeserializer` takes json string and deserialize
    into an object. `serde.msgpack.MsgPackDeserializer` takes msgpack bytes and
    deserialize into an object.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="serde" href="index.html">serde</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="serde.de.deserialize" href="#serde.de.deserialize">deserialize</a></code></li>
<li><code><a title="serde.de.from_dict" href="#serde.de.from_dict">from_dict</a></code></li>
<li><code><a title="serde.de.from_tuple" href="#serde.de.from_tuple">from_tuple</a></code></li>
<li><code><a title="serde.de.is_deserializable" href="#serde.de.is_deserializable">is_deserializable</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="serde.de.Deserializer" href="#serde.de.Deserializer">Deserializer</a></code></h4>
<ul class="">
<li><code><a title="serde.de.Deserializer.deserialize" href="#serde.de.Deserializer.deserialize">deserialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>